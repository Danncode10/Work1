# Version 1.3.1.2: Complete Database Connection & ORM Setup

## Date
12/18/2025

## What We Did

### Environment Setup
- ✅ Configured database connection settings using pydantic-settings
- ✅ Set up SQLAlchemy async database engine and session management
- ✅ Defined ORM models for users and ingredients tables
- ✅ Integrated database setup into FastAPI application
- ✅ Fixed Poetry configuration for proper dependency management

### Documentation Updates
- None

### Files Created/Modified
- Created `backend/app/core/config.py` - Database configuration with environment variables
- Created `backend/app/core/database.py` - SQLAlchemy engine and session setup
- Created `backend/app/models/models.py` - User and Ingredient ORM models
- Created `backend/app/main.py` - FastAPI application with database integration
- Created package `__init__.py` files for proper Python module structure
- Modified `backend/pyproject.toml` - Updated to standard Poetry format

## Brief Summary
In this implementation, we completed the database connection and ORM setup for the Natural Health backend. We configured secure environment-based settings, established an asynchronous database connection using SQLAlchemy and asyncpg, defined data models for users and ingredients, integrated everything into a FastAPI application with automatic table creation, and organized the code into proper Python packages. The backend is now ready to handle database operations asynchronously and can serve as the foundation for API development.

## Detailed Explanations

### Database Configuration (config.py)
Imagine you're setting up a secret code system for your app to talk to the database. The `config.py` file is like your secret decoder ring.

- **pydantic-settings Import**: We use a special tool called `pydantic-settings` that helps read secret information (like database passwords) from a hidden file called `.env`. This tool is like a smart reader that automatically understands different types of information.
- **Settings Class**: We create a `Settings` class that acts like a checklist. It looks for the `DATABASE_URL` (which is like the address of your database home) in the `.env` file located in the parent folder (one level up from the backend folder).
- **Environment File Path**: By using `../.env`, we're telling the code to look outside the backend folder for the secret file. This is important because the `.env` file is in the main project folder, not inside the backend code.
- **Why This Matters**: Just like you wouldn't write your house key on a public sign, we keep database secrets in a separate file. This makes it safe and easy to change settings for different environments (like testing vs. production).

### Database Engine Setup (database.py)
Think of this as building the highway between your app and the database. The `database.py` file creates the connection road.

- **Async Engine Creation**: We build a special "engine" using SQLAlchemy that can handle multiple cars (requests) at the same time on the highway. The word "async" means it can work on several things simultaneously without getting stuck waiting.
- **URL Conversion**: The database address in `.env` starts with `postgresql://`, but for async work, we need to change it to `postgresql+asyncpg://`. This is like switching from a regular car to a sports car that's designed for speed.
- **Session Factory**: We create a "session maker" that produces temporary work sessions. Each session is like a private office where the app can safely work with database data without disturbing others.
- **Why Async?**: Without async, if one user is searching for ingredients, everyone else has to wait. With async, multiple users can search, view details, and browse at the same time, making the app feel fast and responsive.

### ORM Models (models.py)
This is where we create digital blueprints for our data, like designing the structure of Lego blocks before building.

- **Base Class**: Every database table needs a foundation, and `Base` (created by `declarative_base()`) is that foundation. It's like the base plate that all your Lego models stand on.
- **User Model**: This blueprint describes what a user looks like in our database. It has an ID (like a student number), email (unique address), password_hash (secure scrambled password), and created_at (timestamp of when they joined).
- **Ingredient Model**: This blueprint defines what information we store about each natural ingredient. It includes name, benefits (list of good things), risks (list of cautions), nutrition_facts (flexible data about vitamins/minerals), dosage (how much to take), calories (energy content), and references (scientific sources).
- **Data Types**: We choose the right storage type for each piece of information:
  - `ARRAY` for lists (like multiple benefits)
  - `JSONB` for flexible nutrition data (can store complex vitamin/mineral information)
  - `VARCHAR` for text (like ingredient names)
  - `FLOAT` for numbers (like calorie counts)
- **Why ORM?**: Instead of writing complicated SQL code like "SELECT * FROM ingredients WHERE name = 'Turmeric'", we can work with Python objects. It's like speaking English instead of machine language - much easier for humans!

### FastAPI Integration (main.py)
This file is the main control center, like the brain of our application that coordinates everything.

- **App Creation**: We start by creating a FastAPI application, giving it a name ("Natural Health API") and version number. It's like opening a new restaurant and putting up the sign.
- **Database Integration**: We import our database engine and models, connecting the brain to the data storage system.
- **Startup Event**: When the app first starts (like opening the restaurant doors), we use `@app.on_event("startup")` to automatically create all the database tables. This is like setting up all the tables and chairs before customers arrive.
- **Root Route**: We add a simple welcome route at "/" that returns a friendly message. It's like the host greeting guests at the entrance.
- **Why Startup Event?**: We want to make sure all the database tables are ready before the app starts accepting visitors. This prevents errors if someone tries to access data before the storage is set up.

### Package Structure
Python projects are organized like a filing cabinet, and these `__init__.py` files are the folder labels that keep everything organized.

- **__init__.py Files**: These are special files (often empty) that tell Python "this folder is a package." They're like labels on filing cabinet drawers - without them, Python wouldn't know how to find your code.
- **Core Package**: This contains the essential setup files (config and database). It's like the foundation of your house - configuration and data connections.
- **Models Package**: This holds the blueprints for our data (User and Ingredient models). It's like the architectural plans for building database structures.
- **Why Packages?**: Packages allow clean imports throughout your code. Instead of writing long file paths, you can simply say `from app.core import settings` - it's like having shortcuts to frequently used files.

### Poetry Configuration Fix
Poetry is our project manager, and we had to fix its configuration to make it work properly.

- **Format Change**: We switched from the simpler PEP 621 format to Poetry's full `[tool.poetry]` format. It's like upgrading from a basic checklist to a detailed project management system.
- **Package Inclusion**: We added `packages = [{include = "app"}]` to tell Poetry exactly which part of our code to package. It's like telling the manager "focus on the app folder, that's our main product."
- **Why Fix?**: Poetry was confused about how to package our project. It was looking for a README file and proper package structure. By fixing this, Poetry can now properly manage dependencies and create distributable packages.

## Usage Instructions

### Setup Steps
1. Ensure all dependencies are installed: `cd backend && poetry install`
2. Environment variables are loaded from `../.env` automatically
3. Run the application: `poetry run uvicorn app.main:app --reload`

### Configuration
- Database URL is read from the `DATABASE_URL` environment variable
- Tables are created automatically on startup
- Async operations allow handling multiple requests efficiently

### Testing
- Start the server and visit `http://127.0.0.1:8000` for the welcome message
- Check that no import errors occur
- Database tables should be created in PostgreSQL

## Current Status
- Database connection and ORM fully implemented and integrated
- FastAPI application ready for API development
- Backend can connect to PostgreSQL and manage data asynchronously

## Next Steps
- Proceed to Stage 3.2: Implement Authentication APIs
- Add user registration and login endpoints
- Integrate AWS Cognito for user management
